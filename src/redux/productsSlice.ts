import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import axios from "axios";
import { Product, ProductState, ToggleLikeDislikePayload } from "../types/product";

const API_URL = "http://localhost:5000/products";

// Async Thunks
export const fetchProducts = createAsyncThunk<Product[]>("products/fetchProducts", async () => {
  const response = await axios.get(API_URL);
  return response.data;
});

export const addProduct = createAsyncThunk<Product, Omit<Product, "id">>("products/addProduct", async (product) => {
  const response = await axios.post(API_URL, product);
  return response.data; // Make sure this includes the id generated by the backend
});


export const updateProduct = createAsyncThunk<Product, Product>("products/updateProduct", async (product) => {
  const response = await axios.put(`${API_URL}/${product.id}`, product);
  return response.data;
});

export const deleteProduct = createAsyncThunk<string, string>("products/deleteProduct", async (id) => {
  await axios.delete(`${API_URL}/${id}`);
  return id;
});

// Initial State
const initialState: ProductState = {
  products: [],
  filteredProducts: [],
  selectedCategories: [],
  currentPage: 1,
  itemsPerPage: 4,
  status: "idle",
  error: null,
  categories: [], // Initialize categories as an empty array
  
};

// Slice
const productsSlice = createSlice({
  name: "products",
  initialState,
  reducers: {
    setItemsPerPage: (state, action: PayloadAction<number>) => {
      state.itemsPerPage = action.payload;
      state.currentPage = 1; // Reset to first page when items per page changes
    },
    setCurrentPage: (state, action: PayloadAction<number>) => {
      state.currentPage = action.payload;
    },
    filterByCategory: (state, action: PayloadAction<string[]>) => {
      const selectedCategories = action.payload;
      state.selectedCategories = selectedCategories;

      if (selectedCategories.length === 0) {
        state.filteredProducts = state.products;
      } else {
        state.filteredProducts = state.products.filter((product) =>
          selectedCategories.includes(product.category)
        );
      }

      state.currentPage = 1; // Reset to first page on category change
    },
    toggleLikeDislike: (state, action: PayloadAction<ToggleLikeDislikePayload>) => {
      const { id, type } = action.payload;

      const updateLikesDislikes = (productsArray: Product[]) => {
        const product = productsArray.find((product) => product.id === id);
        if (product) {
          if (type === "like") {
            if (product.isLiked) {
              product.likes -= 1;
              product.isLiked = false;
            } else {
              product.likes += 1;
              if (product.isDisliked) {
                product.dislikes -= 1;
                product.isDisliked = false;
              }
              product.isLiked = true;
            }
          } else if (type === "dislike") {
            if (product.isDisliked) {
              product.dislikes -= 1;
              product.isDisliked = false;
            } else {
              product.dislikes += 1;
              if (product.isLiked) {
                product.likes -= 1;
                product.isLiked = false;
              }
              product.isDisliked = true;
            }
          }
        }
      };

      updateLikesDislikes(state.products);
      updateLikesDislikes(state.filteredProducts);
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.products = action.payload.map((product) => ({
          ...product,
          isLiked: false,
          isDisliked: false,
        }));
        state.filteredProducts = [...state.products];
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message || null;
      })
      .addCase(addProduct.fulfilled, (state, action) => {
        state.products.push(action.payload); // Add the product with the generated id to the state
        const newProduct = action.payload;
        state.filteredProducts.push(newProduct);
      
        if (!state.selectedCategories.includes(newProduct.category)) {
          state.selectedCategories.push(newProduct.category);
        }
      })
      
      .addCase(updateProduct.fulfilled, (state, action) => {
        const updatedProduct = action.payload;

        state.products = state.products.map((product) =>
          product.id === updatedProduct.id ? updatedProduct : product
        );

        state.filteredProducts = state.filteredProducts.map((product) =>
          product.id === updatedProduct.id ? updatedProduct : product
        );
      })
      .addCase(deleteProduct.fulfilled, (state, action) => {
        const deletedProductId = action.payload;

        state.products = state.products.filter((product) => product.id !== deletedProductId);
        state.filteredProducts = state.filteredProducts.filter((product) => product.id !== deletedProductId);

        const remainingCategories = [...new Set(state.products.map((product) => product.category))];
        state.selectedCategories = state.selectedCategories.filter((category) =>
          remainingCategories.includes(category)
        );

        const itemsOnPage = Math.ceil(state.filteredProducts.length / state.itemsPerPage);
        if (state.currentPage > itemsOnPage) {
          state.currentPage = itemsOnPage || 1;
        }
      });
  },
});

export const {
  toggleLikeDislike,
  filterByCategory,
  setItemsPerPage,
  setCurrentPage,
} = productsSlice.actions;

// Selectors
export const selectPaginatedProducts = (state: { products: ProductState }) => {
  const startIndex = (state.products.currentPage - 1) * state.products.itemsPerPage;
  return state.products.filteredProducts.slice(startIndex, startIndex + state.products.itemsPerPage);
};

export const selectTotalPages = (state: { products: ProductState }) => {
  return Math.ceil(state.products.filteredProducts.length / state.products.itemsPerPage);
};

export const selectCategories = (state: { products: ProductState }) => {
  return [...new Set(state.products.products.map((product) => product.category))];
};

export default productsSlice.reducer;
